// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

{{#if is_onchain}}
// ityfuzz evm -o -t {{target}} -c {{chain}} --onchain-block-number {{block_number}} -f -i -p --onchain-etherscan-api-key ${{etherscan_keyname}}
{{/if}}
{{#unless is_onchain}}
// ityfuzz evm -t '{{target}}' -f --panic-on-bug
{{/unless}}
/*

ðŸ˜ŠðŸ˜Š Found violations!


{{{solution}}}
 */

contract EGD is Test {
    function setUp() public {
        {{#if is_onchain}}
        vm.createSelectFork("{{chain}}", {{block_number}});
        {{/if}}
    }

    function test() public {
    {{#if need_swap}}
        address router = address({{router}});
        address weth = address({{weth}});
    {{/if}}

{{#each trace}}
    {{#with this}}
        {{! Borrow }}
        {{#if is_borrow}}
        address[] memory path{{borrow_idx}} = new address[](2);
        path{{borrow_idx}}[0] = weth;
        path{{borrow_idx}}[1] = address({{contract}});
        vm.prank(router);
        IUniswapV2Router(router).swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: {{value}}
        }(0, path{{borrow_idx}}, address(this), block.timestamp);
        {{! Liq pencent > 0 }}
        {{#if liq_percent}}
        vm.startPrank(address({{contract}}));
        uint256 amount{{liq_idx}} = IERC20(address({{contract}})).balanceOf(address(this));
        IERC20(address({{contract}})).approve(router, amount1);
        address[] memory liq_path{{liq_idx}} = new address[](2);
        liq_path{{liq_idx}}[0] = address(address({{contract}}));
        liq_path{{liq_idx}}[1] = address(weth);
        IUniswapV2Router(router).swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount1, 0, liq_path{{liq_idx}}, address(this), block.timestamp
        );
        vm.stopPrank();
        {{/if}} {{! Liq pencent end }}
        {{/if}} {{! Borrow end }}
        {{! ABI Call }}
        {{#unless is_borrow}}
        vm.prank(address({{contract}}));
        address({{contract}}).call{{#if value}}{value: {{value}}}{{/if}}(abi.encodeWithSelector(
            {{fn_selector}}{{#if fn_args}},{{fn_args}}{{/if}}
        ));
        {{! Liq pencent > 0 }}
        {{#if liq_percent}}
        vm.startPrank(address({{contract}}));
        uint256 amount{{liq_idx}} = IERC20(address({{contract}})).balanceOf(address(this));
        IERC20(address({{contract}})).approve(router, amount1);
        address[] memory liq_path{{liq_idx}} = new address[](2);
        liq_path{{liq_idx}}[0] = address(address({{contract}}));
        liq_path{{liq_idx}}[1] = address(weth);
        IUniswapV2Router(router).swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount1, 0, liq_path{{liq_idx}}, address(this), block.timestamp
        );
        vm.stopPrank();
        {{/if}}     {{! Liq pencent end }}
        {{/unless}} {{! ABI Call end }}
    {{/with}}
{{/each}}
    }

{{#if stepping_with_return}}
    // Stepping with return
    receive() external payable {}
{{/if}}
}

{{#if need_swap}}
interface IERC20 {
    function balanceOf(address owner) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
}

interface IUniswapV2Router {
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}
{{/if}}
